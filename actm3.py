# -*- coding: utf-8 -*-
"""ActM3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sTAtasRccC8AmxGEdBOPPX8SJ9IiQmei
"""

!pip install simpy

import time
import random
import matplotlib.pyplot as plt

class Vehicle:
    def __init__(self, vehicle_id):
        self.id = vehicle_id
        self.arrival_time = None
        self.x = 0
        self.y = 0

    def send_arrival_time(self, estimated_time):
        self.arrival_time = estimated_time

class TrafficLight:
    def __init__(self, light_id, x, y):
        self.id = light_id
        self.state = "yellow"
        self.nearby_vehicle = None
        self.x = x
        self.y = y

    def change_state(self, new_state):
        self.state = new_state

    def set_light_program(self, vehicle):
        # Logic to set light program based on the proximity of vehicles
        if vehicle.arrival_time < 5:
            self.change_state("green")
        else:
            self.change_state("red")

    def send_light_signal(self):
        return self.state

class Intersection:
    def __init__(self):
        self.traffic_lights = [TrafficLight("A", -1, 0), TrafficLight("B", 1, 0), TrafficLight("C", 0, -1), TrafficLight("D", 0, 1)]
        self.vehicles = []

    def update_traffic_lights(self):
        for light in self.traffic_lights:
            if light.nearby_vehicle:
                light.set_light_program(light.nearby_vehicle)
            else:
                light.change_state("yellow")  # Cambio a luz amarilla si no hay vehículo

    def handle_vehicle_arrival(self, vehicle):
        closest_light = random.choice(self.traffic_lights)
        closest_light.nearby_vehicle = vehicle

    def handle_vehicle_departure(self, vehicle):
        for light in self.traffic_lights:
            if light.nearby_vehicle == vehicle:
                light.nearby_vehicle = None

# Inicializamos la visualización
def plot_intersection(vehicles, lights):
    plt.xlim(-2, 2)
    plt.ylim(-2, 2)
    plt.gca().set_aspect('equal', adjustable='box')
    plt.grid()

    for light in lights:
        color = 'green' if light.state == 'green' else 'yellow' if light.state == 'yellow' else 'red'
        plt.scatter(light.x, light.y, color=color, s=100, edgecolor='black')
        plt.text(light.x, light.y, light.id, ha='center', va='center', fontsize=12)

    for vehicle in vehicles:
        plt.scatter(vehicle.x, vehicle.y, color='blue', s=50, edgecolor='black')
        plt.text(vehicle.x, vehicle.y, str(vehicle.id), ha='center', va='center', fontsize=10)

    plt.show()

# Simulación
intersection = Intersection()

# Ciclo de simulación
while True:
    # Simulamos la llegada de un vehículo cada cierto tiempo
    time.sleep(random.randint(1, 5))
    vehicle = Vehicle(random.randint(1, 100))
    vehicle.send_arrival_time(random.randint(1, 10))
    vehicle.x = random.uniform(-1.5, 1.5)
    vehicle.y = random.uniform(-1.5, 1.5)
    intersection.handle_vehicle_arrival(vehicle)
    print(f"Vehicle {vehicle.id} approaching intersection with arrival time {vehicle.arrival_time}")

    # Actualizamos el estado de los semáforos
    intersection.update_traffic_lights()

    # Visualizamos la intersección
    plot_intersection(intersection.vehicles, intersection.traffic_lights)

    # Simulamos el movimiento de los vehículos
    for _ in range(10):
        for vehicle in intersection.vehicles:
            vehicle.x += random.uniform(-0.05, 0.05)
            vehicle.y += random.uniform(-0.05, 0.05)

    # Simulamos la salida de un vehículo cada cierto tiempo
    time.sleep(random.randint(1, 5))
    intersection.handle_vehicle_departure(vehicle)
    print(f"Vehicle {vehicle.id} left intersection")